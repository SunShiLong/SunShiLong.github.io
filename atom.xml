<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学不车</title>
  <icon>https://www.gravatar.com/avatar/b6b5b12bec5eefda89480d0aa50e9688</icon>
  <subtitle>一天不学问题多，两天不学走下坡。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://SunShiLong.github.io/"/>
  <updated>2018-05-09T12:07:16.898Z</updated>
  <id>http://SunShiLong.github.io/</id>
  
  <author>
    <name>孙世龙</name>
    <email>1577908011@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自动化打包测试之蒲公英</title>
    <link href="http://SunShiLong.github.io/2018/05/09/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E6%B5%8B%E8%AF%95%E4%B9%8B%E8%92%B2%E5%85%AC%E8%8B%B1/"/>
    <id>http://SunShiLong.github.io/2018/05/09/自动化打包测试之蒲公英/</id>
    <published>2018-05-09T12:00:00.000Z</published>
    <updated>2018-05-09T12:07:16.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动化打包测试之蒲公英"><a href="#自动化打包测试之蒲公英" class="headerlink" title="自动化打包测试之蒲公英"></a>自动化打包测试之蒲公英</h1><blockquote><p>前言</p><p>目标：采用python脚本，一键自动化打包测试。</p></blockquote><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="一、安装Python环境"><a href="#一、安装Python环境" class="headerlink" title="一、安装Python环境"></a>一、安装Python环境</h3><p>1、下载Python并安装，<a href="https://www.python.org/downloads/mac-osx/" target="_blank" rel="external">地址</a></p><p>2、安装pip</p><pre><code>sudo easy_install pip</code></pre><p>3、安装requests网络请求库</p><pre><code>sudo easy_install requests</code></pre><p>4、下载脚本：<a href="https://github.com/longgeshashen/iOSAutoPage.git" target="_blank" rel="external">地址</a></p><h2 id="二、配置脚本文件"><a href="#二、配置脚本文件" class="headerlink" title="二、配置脚本文件"></a>二、配置脚本文件</h2><h3 id="1、配置路径"><a href="#1、配置路径" class="headerlink" title="1、配置路径"></a>1、配置路径</h3><p><strong><em>Xcode的products下App路径：</em></strong> appFileFullPath = ‘/Users/Qinz/Library/Developer/Xcode/DerivedData/DDDS-bcghxucdqelptddawpsfmvjtoefm/Build/Products/Debug-iphoneos/DDDS.app’</p><p><strong><em>App中转路径：</em></strong> PayLoadPath = ‘/Users/Qinz/Desktop/Payload’</p><p><strong><em>自动打包目的地路径：</em></strong> packBagPath = ‘/Users/Qinz/Desktop/ProgramBag’</p><h3 id="2、配置蒲公英Key"><a href="#2、配置蒲公英Key" class="headerlink" title="2、配置蒲公英Key"></a>2、配置蒲公英Key</h3><p>在蒲公英的App管理页面API下有提供</p><p>USER_KEY = “61ded40a68axxxxxxe9fd278acd2”</p><p>API_KEY = “a4fe2724dc6d8cxxxxxxf1994eec219e”</p><p>如下图<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oxftt42c0.bkt.clouddn.com/pugyer.jpeg" alt="相关key" title="">                </div>                <div class="image-caption">相关key</div>            </figure></p><h3 id="3、配置密码"><a href="#3、配置密码" class="headerlink" title="3、配置密码"></a>3、配置密码</h3><pre><code>data={            &apos;uKey&apos;:USER_KEY,            &apos;_api_key&apos;:API_KEY,            &apos;installType&apos;:&apos;2&apos;,            &apos;password&apos;:&apos;123456&apos;, #4、设置密码            &apos;updateDescription&apos;:des        }</code></pre><h3 id="4、配置openUrl"><a href="#4、配置openUrl" class="headerlink" title="4、配置openUrl"></a>4、配置openUrl</h3><p>上传成功，自动打开App管理页面或者App下载页面</p><pre><code>openUrl = &apos;https://www.pgyer.com/manager/dashboard/app/xxx&apos;</code></pre><h2 id="三、打包上传"><a href="#三、打包上传" class="headerlink" title="三、打包上传"></a>三、打包上传</h2><p>1、command+B 编译工程</p><p>2、执行脚本： python  DaBao.py </p><p>3、输入更新信息（加英文双引号）：“这个版本更新了XXX内容，更新人员AAA。”</p><p>参考文章：</p><p><a href="https://www.jianshu.com/p/1f47066da6f7" target="_blank" rel="external">简书</a></p><p><a href="https://www.python.org/downloads/mac-osx/" target="_blank" rel="external">Python</a></p><p><a href="https://www.zhihu.com/question/50470150" target="_blank" rel="external">知乎</a></p><p><a href="https://blog.csdn.net/sunflowerssssss/article/details/53761406" target="_blank" rel="external">CSDN</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自动化打包测试之蒲公英&quot;&gt;&lt;a href=&quot;#自动化打包测试之蒲公英&quot; class=&quot;headerlink&quot; title=&quot;自动化打包测试之蒲公英&quot;&gt;&lt;/a&gt;自动化打包测试之蒲公英&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;目标：采用python
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://SunShiLong.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ActiveSQLite数据库操作说明</title>
    <link href="http://SunShiLong.github.io/2018/05/07/ActiveSQLite%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/"/>
    <id>http://SunShiLong.github.io/2018/05/07/ActiveSQLite数据库操作说明/</id>
    <published>2018-05-07T07:14:00.000Z</published>
    <updated>2018-05-07T07:14:56.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ActiveSQLite数据库操作说明"><a href="#ActiveSQLite数据库操作说明" class="headerlink" title="ActiveSQLite数据库操作说明"></a>ActiveSQLite数据库操作说明</h1><p><code>前言</code></p><pre><code>pod &quot;ActiveSQLite&quot;</code></pre><p><code>优点：</code></p><ol><li>自动建表</li><li>基于SQLite.swift数据库</li><li>不需要写Expression表达式</li><li>增删改查支持String和key-value字典操作</li><li>查询结果自动包装成对象</li><li>支持事务操作和异步操作</li><li>模型和数据库表映射</li><li>带有日志系统</li><li>数据库可以升级</li></ol><h2 id="一、特点"><a href="#一、特点" class="headerlink" title="一、特点"></a>一、特点</h2><p>1、支持的数据类型<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oxftt42c0.bkt.clouddn.com/Swift_ActiveSQLite_surport_dataType.jpeg" alt="数据类型" title="">                </div>                <div class="image-caption">数据类型</div>            </figure></p><p>NSNumber类型对应SQLite.swift的两种类型（Int64和Double)。NSNumber默认的映射类型是Int64。重写DBModel的doubleTypes()方法能标记属性为Double类型。</p><pre><code>class T_BLE_DEVICE: DBModel {    var Major:NSNumber?    var Minor:NSNumber?    var RssiAnd: NSNumber?    var RssiIos: NSNumber?    var RssiDlj: NSNumber?    var AccIos : NSNumber?    var IsAdjusted:NSNumber?    //标记double类型    override func doubleTypes() -&gt; [String]{        return [&quot;AccIos&quot;]    }}</code></pre><h2 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h2><h3 id="1、手动建数据库"><a href="#1、手动建数据库" class="headerlink" title="1、手动建数据库"></a>1、手动建数据库</h3><pre><code>func createMyselfDB() {        let fileManager = FileManager.default        let myDirectory = NSHomeDirectory() + &quot;/Documents/DBFile/&quot;        let filePath = myDirectory.appending(&quot;aaa.db&quot;)        print(filePath)        let exsit = fileManager.fileExists(atPath: filePath)        if !exsit {            //创建数据库            try! fileManager.createDirectory(atPath: myDirectory, withIntermediateDirectories: true, attributes: nil)            let result = fileManager.createFile(atPath: filePath, contents: nil, attributes: nil)            print(result)        }}</code></pre><h3 id="1-1连接现有数据库"><a href="#1-1连接现有数据库" class="headerlink" title="1.1连接现有数据库"></a>1.1连接现有数据库</h3><pre><code>//连接现有数据库        let dbFile = Bundle.main.path(forResource: &quot;DataBase&quot;, ofType: &quot;db&quot;)        DBConfigration.setDefaultDB(path: dbFile!, name: &quot;DataBase.db&quot;)</code></pre><h3 id="2、手动建表"><a href="#2、手动建表" class="headerlink" title="2、手动建表"></a>2、手动建表</h3><pre><code>MARK: ---创建表（可以省略，数据库会自动创建表）        do {           try Person.createTable()        }        catch {        }</code></pre><h3 id="2-1、自动建表"><a href="#2-1、自动建表" class="headerlink" title="2.1、自动建表"></a>2.1、自动建表</h3><p>为了演示数据库操作建立两个模型Person.swift和T_BLE_DEVICE.swift</p><pre><code>//model1import UIKitimport ActiveSQLiteclass Person: DBModel {    var name:String!    var price:NSNumber!    var age: NSNumber!}//model2import UIKitimport ActiveSQLiteclass T_BLE_DEVICE: DBModel {    var Major:NSNumber?    var Minor:NSNumber?    var RssiAnd: NSNumber?    var RssiIos: NSNumber?    var RssiDlj: NSNumber?    var AccIos : NSNumber?    var IsAdjusted:NSNumber?    //标记double类型    override func doubleTypes() -&gt; [String]{        return [&quot;AccIos&quot;]    }}</code></pre><blockquote><p><strong>手动建表这步可省略，数据库会根据模型自动建表</strong></p></blockquote><h3 id="3、连接数据库"><a href="#3、连接数据库" class="headerlink" title="3、连接数据库"></a>3、连接数据库</h3><pre><code>//MARK: ----- 连接数据库        DBConfigration.setDefaultDB(path:filePath, name: &quot;aaa.db&quot;)</code></pre><h3 id="4、设置日志级别"><a href="#4、设置日志级别" class="headerlink" title="4、设置日志级别"></a>4、设置日志级别</h3><pre><code>//MARK: ----- 日志级别        /*         1、有四种日志级别，分别是: debug,info,warn,error。         2、默认的日志级别是info。         3、首先设置日志级别，后设置数据库路径         */        DBConfigration.logLevel = .warn</code></pre><h2 id="三、CURD（增改查删）"><a href="#三、CURD（增改查删）" class="headerlink" title="三、CURD（增改查删）"></a>三、CURD（增改查删）</h2><p>===================================== 增 ============================================</p><h3 id="1-1、保存一条数据"><a href="#1-1、保存一条数据" class="headerlink" title="1.1、保存一条数据"></a>1.1、保存一条数据</h3><pre><code>//MARK: --- 1、保存数据                let per:Person = Person()                per.name = &quot;Alon&quot;                per.price = 13                per.age = 5                try! per.save()</code></pre><h3 id="1-2、插入一条数据"><a href="#1-2、插入一条数据" class="headerlink" title="1.2、插入一条数据"></a>1.2、插入一条数据</h3><pre><code>//MARK: --- 2、插入一条数据                let person1 = Person()                person1.name = &quot;Bolee&quot;                person1.price = 25                person1.age = 5                try! person1.insert()</code></pre><h3 id="1-3、插入多条数据"><a href="#1-3、插入多条数据" class="headerlink" title="1.3、插入多条数据"></a>1.3、插入多条数据</h3><pre><code>//MARK: --- 3、插入多条数据                var personArray = [Person]()                for i in 1...8 {                    let p = Person()                    p.name = &quot;student-\(i)&quot;                    p.price = 10 + i as NSNumber                    p.age = 5                    personArray.append(p)                }                try! Person.insertBatch(models: personArray)</code></pre><p>===================================== 查 ============================================</p><h3 id="2-1、查询第一条数据"><a href="#2-1、查询第一条数据" class="headerlink" title="2.1、查询第一条数据"></a>2.1、查询第一条数据</h3><pre><code>let person = Person.findFirst(&quot;name&quot;, value: &quot;Bolee&quot;) as! Personprint(person)</code></pre><h3 id="2-2、查询多条数据"><a href="#2-2、查询多条数据" class="headerlink" title="2.2、查询多条数据"></a>2.2、查询多条数据</h3><pre><code>let persons = Person.findAll([&quot;name&quot; : &quot;Bolee&quot;], [&quot;price&quot; : true]) as! [Person]print(persons.count)</code></pre><h3 id="2-3、通过Expression查询"><a href="#2-3、通过Expression查询" class="headerlink" title="2.3、通过Expression查询"></a>2.3、通过Expression查询</h3><pre><code>let id = Expression&lt;NSNumber&gt;(&quot;id&quot;)let name1 = Expression&lt;String&gt;(&quot;name&quot;)let price = Expression&lt;NSNumber&gt;(&quot;price&quot;)let array = Person.findAll(name1 == &quot;Bolee&quot;) as! Array&lt;Person&gt;print(array.count)let array1 = Person.findAll(id &lt; NSNumber(value: 10), orders: [Person.id.asc]) as! Array&lt;Person&gt;print(array1.count)</code></pre><h3 id="2-4、链式查询"><a href="#2-4、链式查询" class="headerlink" title="2.4、链式查询"></a>2.4、链式查询</h3><pre><code>let array3 = Person().where(Expression&lt;NSNumber&gt;(&quot;id&quot;) &gt; 3)    .order(Person.id)    .limit(20)    .run() as! [Person]print(array3.count)</code></pre><p>===================================== 改 ============================================</p><h3 id="3-1、通过属性值修改"><a href="#3-1、通过属性值修改" class="headerlink" title="3.1、通过属性值修改"></a>3.1、通过属性值修改</h3><pre><code>person.name = &quot;Angle&quot;try! person.save()print(person)</code></pre><h3 id="3-2、通过属性名字符串和属性值"><a href="#3-2、通过属性名字符串和属性值" class="headerlink" title="3.2、通过属性名字符串和属性值"></a>3.2、通过属性名字符串和属性值</h3><pre><code>try! person.update(&quot;price&quot;, value: NSNumber(value: 100))       //单属性修改try! person.update([&quot;name&quot;: &quot;Dove&quot;,&quot;price&quot;:NSNumber(value: 200)]) //多属性修改try! Person.update([&quot;name&quot;: &quot;Maly&quot;,&quot;price&quot;:NSNumber(value: 300)], where: [&quot;id&quot;: NSNumber(value:1)]) //批量修改</code></pre><h3 id="3-3、通过SQLite-swift的Setter"><a href="#3-3、通过SQLite-swift的Setter" class="headerlink" title="3.3、通过SQLite.swift的Setter"></a>3.3、通过SQLite.swift的Setter</h3><pre><code>let price = Expression&lt;NSNumber&gt;(&quot;price&quot;)try! person?.update(price &lt;- NSNumber(value: 110))</code></pre><p>===================================== 删 ============================================</p><h3 id="4-1、删除一条数据"><a href="#4-1、删除一条数据" class="headerlink" title="4.1、删除一条数据"></a>4.1、删除一条数据</h3><pre><code>try? person?.delete()</code></pre><h3 id="4-2、清空表"><a href="#4-2、清空表" class="headerlink" title="4.2、清空表"></a>4.2、清空表</h3><pre><code>try? Person.deleteAll()</code></pre><h3 id="4-3、链式删除"><a href="#4-3、链式删除" class="headerlink" title="4.3、链式删除"></a>4.3、链式删除</h3><pre><code>try? Person().where(Expression&lt;NSNumber&gt;(&quot;id&quot;) &gt; 20)            .runDelete()</code></pre><h2 id="四、高级用法"><a href="#四、高级用法" class="headerlink" title="四、高级用法"></a>四、高级用法</h2><h3 id="1、表重命名、"><a href="#1、表重命名、" class="headerlink" title="1、表重命名、"></a>1、表重命名、</h3><pre><code>try? Person.renameTable(oldName: &quot;Person&quot;, newName: &quot;Pepole&quot;)</code></pre><h3 id="2、添加新的属性"><a href="#2、添加新的属性" class="headerlink" title="2、添加新的属性"></a>2、添加新的属性</h3><ul><li>1、先在模型类里添加属性</li><li><p>2、调用addColumn</p><pre><code>try? Person.addColumn([&quot;age&quot;])   //可添加多个属性</code></pre></li></ul><h3 id="3、删除表"><a href="#3、删除表" class="headerlink" title="3、删除表"></a>3、删除表</h3><pre><code>try? Person.dropTable()</code></pre><h3 id="4、异步事务（重点来了…-）"><a href="#4、异步事务（重点来了…-）" class="headerlink" title="4、异步事务（重点来了….）"></a>4、异步事务（重点来了….）</h3><ul><li>建议把所有的insert，update，delete操作和alter表的代码全部放在ActiveSQLite.save代码块中。一个块中的sql操作在同一个事务当中</li><li>建议所有增删改查操作用异步事务saveAsync</li></ul><pre><code>func makeAsync() {        ActiveSQLite.saveAsync({            var ps = [Person]()            for i in 0 ..&lt; 3 {                let p = Person()                p.name = &quot;Teacher-\(i)&quot;                p.price = i as NSNumber                ps.append(p)            }            try! Person.insertBatch(models: ps)        }, completion: { (error) in            if error != nil {                debugPrint(&quot;transtion fails \(error.debugDescription)&quot;)            }else{                debugPrint(&quot;transtion success&quot;)            }        })    }</code></pre><p>参考文章：<a href="https://blog.csdn.net/wuming_apie/article/details/77337697" target="_blank" rel="external">源头</a></p><p>代码地址：<a href="https://git.coding.net/sunshilong/SwiftSQL.git" target="_blank" rel="external">Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ActiveSQLite数据库操作说明&quot;&gt;&lt;a href=&quot;#ActiveSQLite数据库操作说明&quot; class=&quot;headerlink&quot; title=&quot;ActiveSQLite数据库操作说明&quot;&gt;&lt;/a&gt;ActiveSQLite数据库操作说明&lt;/h1&gt;&lt;p&gt;&lt;c
      
    
    </summary>
    
    
      <category term="Swift" scheme="http://SunShiLong.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>蜂鸟云平台SDK使用攻略</title>
    <link href="http://SunShiLong.github.io/2018/04/16/**%E8%9C%82%E9%B8%9F%E4%BA%91%E5%B9%B3%E5%8F%B0SDK%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5**/"/>
    <id>http://SunShiLong.github.io/2018/04/16/**蜂鸟云平台SDK使用攻略**/</id>
    <published>2018-04-16T00:32:00.000Z</published>
    <updated>2018-04-16T00:32:24.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蜂鸟云平台SDK使用攻略"><a href="#蜂鸟云平台SDK使用攻略" class="headerlink" title="蜂鸟云平台SDK使用攻略"></a><strong>蜂鸟云平台SDK使用攻略</strong></h1><blockquote><p>目录</p></blockquote><ul><li>平台简介</li><li>前期准备</li><li>接入SDK</li><li>功能介绍</li><li>Demo展示</li></ul><h2 id="平台简介"><a href="#平台简介" class="headerlink" title="平台简介"></a>平台简介</h2><p>蜂鸟地图可以提供三维室内地图体验，可以定制或绘制各种样式的三维地图。</p><p>Fengmap SDK是一套跨平台的地图引擎，只需要使用蜂鸟三维室内地图和SDK，便可快捷的开发Android、iOS、Web端地图应用，集成在APP、公众号或网站中。</p><p>Fengmap SDK 广泛支持多种室内定位技术，可快速完成室内定位对接、功能开发以及项目实施。</p><p>蜂鸟云地图编辑器是国内首创的SaaS室内地图全要素编辑器，面向企业机构和个人用户提供在线室内地图制作与编辑服务。编辑器具备专业的室内地图制图能力，可以简单、快速的进行地图空间元素、公共设施、路径数据的绘制和修改，并对地图主题样式、属性数据、图标资源进行选择编辑和管理。</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>Fengmap iOS SDK 可以实现<code>地图显示与操作</code>、<code>覆盖物</code>、<code>查询分析</code>和<code>路径导航</code>4部分功能。前期准备需要以下几点：</p><ol><li>开发工具、：Xcode7.0以上</li><li>SDK：V2.0.0以上，老版本已不兼容</li><li>注册为蜂鸟用户</li><li>注册App秘钥（当前用户可以免费创建不超过50个App）</li><li>下载SDK包<a href="https://www.fengmap.com/develop-ios-download.html" target="_blank" rel="external">最新版本</a></li><li>设备联网，蜂鸟SDK密钥需要在应用首次运行时连接网络</li><li>加载地图会默认设置一套Fengmap自定义主题，该主题文件不可以删除，否则会导致程序崩溃</li><li>若需要替换定位、指北针的图标请保留原文件名称，否则不显示替换的新图片</li><li><strong>根据需求，上传资料，蜂鸟平台会帮助制作地图XXX.fmap。下载即可使用</strong></li><li>上传资料样例：<a href="https://www.fengmap.com/help-faq-detail.html?id=5-23" target="_blank" rel="external">模板</a></li></ol><h2 id="接入SDK"><a href="#接入SDK" class="headerlink" title="接入SDK"></a>接入SDK</h2><ol><li>将SDK的libs文件夹拷贝到您的Application工程根目录下</li><li>Other Linker Flags中添加-ObjC</li><li>设置静态库的链接路径，Library Search Paths中添加您的静态库目录，比如<code>$(SRCROOT)/../libs/Release-$( PLATFORM_NAME)</code>，<code>$(SRCROOT)</code>宏代表您的工程文件目录,<code>$( PLATFORM_NAME)</code>宏代表当前配置是iOS Device还是Simulator。</li><li>静态库中采用Objective-C和C++混合实现，因此需要您保证您工程中至少有一个.mm后缀的源文件</li><li>添加系统库：CoreGraphics.framework、OpenGLES.framework、GLKit.framework、Security.framework</li><li>将TARGETS-Build Settings-C++ Language Dialect项选择为：GNU++11[-std=gnu++11]<br>TARGETS-Build Settings-C++ Standard Library一项改为： Libstdc++(GNU C++ standard library)</li><li>引入FMBundle.bundle资源文件（存储了公共设施、定位、指北针等资源图片，还存储了地图的默认主题文件）</li></ol><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><h3 id="一、地图创建"><a href="#一、地图创建" class="headerlink" title="一、地图创建"></a>一、地图创建</h3><blockquote><p>添加秘钥</p></blockquote><pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {// Override point for customization after application launch.NSLog(@&quot;请输入您在蜂鸟云平台申请的key&quot;);// appKey从官网控制台获取[[FMKMapSDK shareSDK] setKey:@&quot;65f0abda4ca87adc4f3283b333fd11c7&quot;];return YES;}</code></pre><p>在蜂鸟网站，通过地图ID下载地图数据，地图数据是.fmap格式的文件在200k左右。</p><h3 id="二、地图显示"><a href="#二、地图显示" class="headerlink" title="二、地图显示"></a>二、地图显示</h3><pre><code>- (void)viewDidLoad {    [super viewDidLoad];    // 通过地图ID初始化地图视图    self.mapView = [[FMKMapView alloc] initWithFrame:rect ID:_mapID delegate:self autoUpgrade:NO];    [self.view addSubview:_mapView];}</code></pre><blockquote><p>地图显示包含以下功能点：</p></blockquote><ol><li>楼层：一层或多层，显示多层时焦点层不透明，其他楼层透明</li><li>缩放：缩放范围1~29，可以设置默认缩放级别，及缩放范围</li><li>倾斜：地图初始化后可以设置地图的倾斜角度</li><li>旋转：地图初始化后可以设置地图的旋转角度</li><li>二三维：Fengmap地图有二维、三维两种显示模式</li><li>坐标转换：SDK 提供设备屏幕坐标和地图坐标之间的转换方法，转换方法在FMKMapView内</li><li>设置主题：可以到网站下载，可以设置离线主题</li><li>离线地图：下载地图资源离线操作</li></ol><h3 id="三、地图交互"><a href="#三、地图交互" class="headerlink" title="三、地图交互"></a>三、地图交互</h3><blockquote><p>地图控制：</p></blockquote><ol><li>设置中心点</li><li>地图移动</li><li>地图缩放</li><li>地图倾斜</li><li>地图旋转</li><li>手势控制（旋转、缩放、拖拽、点击、双击、长按、轻扫）</li><li>自定义手势</li><li>动画控制</li></ol><blockquote><p>地图控件</p></blockquote><ol><li>指北针</li><li>缩放控件</li><li>楼层切换控件</li><li>多楼层显示控件</li><li>二三维切换控件</li></ol><blockquote><p>事件方法</p></blockquote><ol><li>地图事件包括</li><li>地图加载事件，</li><li>地图更新事件，</li><li>地图单击、双击、长按、移动事件。</li></ol><p>可以通过实现FMKMapViewDelegate 协议的方法对事件进行其他操作。</p><blockquote><p>图层节点点击事件</p></blockquote><p>可以通过图层节点点击事件拾取到地图上的节点元素。图层节点的点击事件需要设置图层对象的代理，然后实现 FMKLayerDelegate (层节点协议) 的方法。<br>地图元素拾取事件按照 model、facility、imageMarker、locationMarker、textMarker 的顺序拾取，任何一个图层响应拾取事件，都会阻拦拾取事件的向下传递。</p><h3 id="四、地图绘制"><a href="#四、地图绘制" class="headerlink" title="四、地图绘制"></a>四、地图绘制</h3><blockquote><p>点标准</p></blockquote><ol><li>图片标注：在指定坐标点位置添加自定义的图片标识</li><li>文字标注：在指定坐标点添加自定义文字内容</li><li>定位点标注：在指定坐标点位置添加的用于导航过程中展示位置的标识</li><li>气泡窗标注：气泡窗口为用户自定义View，可根据用户需求在地图上添加相应的视图。气泡窗口支持动态更新位置。</li></ol><blockquote><p> 绘制形状</p></blockquote><ol><li>线：用户可根据坐标点集绘制折线。注：线是针对整个地图的，线段的点可以是不同楼层的点</li><li>多边形：Fengmap iOS SDK 支持绘制多边形操作。用户可根据坐标点集绘制多边形，注：多边形是针对楼层的，每一楼层可包含多个多边形</li><li>矩形：Fengmap iOS SDK 支持绘制矩形操作。用户可根据中心点坐标和宽高绘制矩形，注：矩形是针对楼层的，每一楼层可包含多个矩形</li><li>圆形：Fengmap iOS SDK 支持绘制圆形操作。用户可根据中心点坐标和半径绘制圆形，注：圆形是针对楼层的，每一楼层可包含多个圆形</li></ol><h3 id="五、查询地图数据"><a href="#五、查询地图数据" class="headerlink" title="五、查询地图数据"></a>五、查询地图数据</h3><blockquote><p>信息查询</p></blockquote><p>Fengmap iOS SDK提供对数据模型（model）、公共设施(facility)的查询接口, 可以根据关键字或者类型查询模型和公共设施<br>FID查询<br>Type查询<br>关键字查询</p><blockquote><p>周边检索</p></blockquote><p>开发者可设置查询中心点和半径，对该圆形区域进行查询搜索。</p><blockquote><p>自有数据检索</p></blockquote><p>Fengmap iOS SDK支持对数据模型（model）、公共设施(facility)、自定义标注(marker)等地图元素的搜索分析。自有数据的查询是您的业务数据。可通过地图数据内的某个字段与自有数据相关联，分两步查询：第一步先查询外部数据获取到所关联的地图数据字段；第二步根据地图数据字段进行地图查询。<br>注：本示例以*.fmap数据中的FID字段与自有数据中的FID关联为例，实际中也可通过其他字段关联与地图中的FID字段关联。地图中的FID字段为全地图唯一标识。</p><h3 id="六、路径规划与导航"><a href="#六、路径规划与导航" class="headerlink" title="六、路径规划与导航"></a>六、路径规划与导航</h3><blockquote><p>路径规划</p></blockquote><ol><li>Fengmap iOS SDK支持根据起点和终点坐标规划路线功能。 </li><li>Fengmap iOS SDK 提供文字导航描述功能。在路径分析成功后，路径分析对象会自动生成相应的文字描述和路段信息。</li></ol><blockquote><p>定位导航</p></blockquote><p>Fengmap iOS SDK 结合定位技术，可实现导航的功能。SDK提供导航工具类，使导航开发变得很简单，开发者可根据本示例结合实际定位系统，实现真实的定位导航功能。</p><p>Demo下载地址<a href="https://www.fengmap.com/develop-ios-download.html" target="_blank" rel="external">7个子Demo最新版</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;蜂鸟云平台SDK使用攻略&quot;&gt;&lt;a href=&quot;#蜂鸟云平台SDK使用攻略&quot; class=&quot;headerlink&quot; title=&quot;蜂鸟云平台SDK使用攻略&quot;&gt;&lt;/a&gt;&lt;strong&gt;蜂鸟云平台SDK使用攻略&lt;/strong&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="教程" scheme="http://SunShiLong.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Runtime机制</title>
    <link href="http://SunShiLong.github.io/2018/02/12/Runtime%E8%AF%A6%E8%A7%A3/"/>
    <id>http://SunShiLong.github.io/2018/02/12/Runtime详解/</id>
    <published>2018-02-11T16:00:00.000Z</published>
    <updated>2018-02-12T08:56:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预热几个知识点"><a href="#预热几个知识点" class="headerlink" title="预热几个知识点"></a>预热几个知识点</h3><h2 id="一、所有都是对象，方法都是消息"><a href="#一、所有都是对象，方法都是消息" class="headerlink" title="一、所有都是对象，方法都是消息"></a>一、所有都是对象，方法都是消息</h2><blockquote><p>1、OC中所有id类型都被设计成对象，类本身也是一个对象。OC代码在运行时会动态转化为C代码。</p><p>2、所有方法调用都是发消息，例如<code>[self init];</code>被转化为<code>objc_msgSend(self,@selector(init))</code></p></blockquote><p>在OC中id指针，可以代表所有对象，其实id是结构体，我们看看id的具体结构：</p><pre><code>struct objc_class {    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;#if !__OBJC2__    Class _Nullable super_class                              OBJC2_UNAVAILABLE;    const char * _Nonnull name                               OBJC2_UNAVAILABLE;    long version                                             OBJC2_UNAVAILABLE;    long info                                                OBJC2_UNAVAILABLE;    long instance_size                                       OBJC2_UNAVAILABLE;    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;#endif} OBJC2_UNAVAILABLE;</code></pre><p><strong>这是属性都是什么意思呢？下面一一介绍</strong></p><ul><li>.Class 的isa指针，指向元类</li><li>.super_class ：指向超类</li><li>.name是类名</li><li>.version是类版本信息</li><li>.info是这个类的详情信息</li><li>.instance_size是这个类实例对象的大小</li><li>.ivars是类成员变量</li><li>.methodLists类的方法列表</li><li>.cache是，存储被调用过的方法，方便下次使用</li><li>.protocols是类的协议列表</li></ul><h2 id="二、方法调用顺序"><a href="#二、方法调用顺序" class="headerlink" title="二、方法调用顺序"></a>二、方法调用顺序</h2><ol><li>调用一个<code>方法A</code>，首先runtime把方法转为消息发送，可以简单理解为<code>objc_msgSend</code>。</li><li>在<code>cache</code>里查找，找到执行，否则</li><li>在本类的<code>methodLists</code>中查找，找到执行，否则</li><li>在父类中重复2、3步骤</li><li>直到<code>根类NSObject</code>都没找到，转向<code>方法拦截</code></li><li>动态解析<code>方法A</code>，判断是不是系统忽略方法，例如retain、release等</li><li>判断<code>调用者target</code>是不是nil，<code>OC语法允许nil对象调用不存在方法而不Crash</code>。</li><li>进入第二阶段，<code>消息转发</code></li><li>进入 <code>resolveInstanceMethod:</code> 方法。如果返回YES，调用<code>class_addMethod</code>，执行方法完成。如果返回NO，向下</li><li>进入重定向 <code>forwardingTargetForSelector:</code> ，指定一个可以实现<code>方法A</code>对象，完成这次调用。如果返回nil，向下</li><li>进入方法签名操作 <code>methodSignatureForSelector:</code> ，如果签名成功，有返回值，这时会调用消息转发方法<code>forwardInvocation:</code>。</li><li>在<code>forwardInvocation:</code>中可以修改实现方法、修改响应对象。</li></ol><h2 id="三、获取参数"><a href="#三、获取参数" class="headerlink" title="三、获取参数"></a>三、获取参数</h2><p><strong>runtime可以获取类的各种参数，方法如下：</strong></p><ul><li>class_copyPropertyList：获取属性列表</li><li>class_copyMethodList：获取方法列表</li><li>class_copyIvarList：获取成员变量</li><li>class_copyProtocolList：获取协议列表</li></ul><h1 id="Runtime用途"><a href="#Runtime用途" class="headerlink" title="Runtime用途"></a>Runtime用途</h1><h2 id="一、直接通过C发送消息，来调用方法"><a href="#一、直接通过C发送消息，来调用方法" class="headerlink" title="一、直接通过C发送消息，来调用方法"></a>一、直接通过C发送消息，来调用方法</h2><ul><li>objc_msgSend:调用普通方法</li><li>objc_msgSend_stret：消息返回值是数据结构</li><li>objc_msgSend_fpret：消息返回值是浮点数</li><li>objc_msgSendSuper：调用父类方法</li><li>objc_msgSendSuper_stret：父类消息返回值是数据结构</li></ul><p><strong>通过代码来说明下：</strong></p><p>新建一个Person类</p><pre><code>@interface Person : NSObject@property (nonatomic,strong) NSString  *name;@property (nonatomic,strong) NSString  *idcard;@property (nonatomic)        NSInteger age;</code></pre><p>person有下面方法</p><pre><code>- (void)hello:(NSString*)name andAge:(NSInteger)age;- (NSString*)goodMornig:(NSString*)name;- (float)getHeight;</code></pre><p>正常情况下，OC调用方法如下</p><pre><code>Person *person = [[Person alloc] init];[person hello:@&quot;Dave&quot; andAge:12];</code></pre><p>在runtime机制下，可以直接用c方法调用，如下</p><pre><code>1、((void (*) (id, SEL)) objc_msgSend) (person, sel_registerName(&quot;hello:andAge:&quot;));2、NSString *str = ((NSString* (*) (id, SEL)) objc_msgSend) (person, sel_registerName(&quot;goodMornig:&quot;));3、float f = ((float (*) (id, SEL)) objc_msgSend_fpret) (objct, sel_registerName(&quot;getHeight&quot;));</code></pre><h2 id="二、关联对象"><a href="#二、关联对象" class="headerlink" title="二、关联对象"></a>二、关联对象</h2><p>允许开发者对已经存在的对象在 Category 中添加自定义的属性：<br>设置关联对象核心方法是：</p><p><code>OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</code></p><h3 id="参数解析："><a href="#参数解析：" class="headerlink" title="参数解析："></a>参数解析：</h3><ul><li>.object:源对象</li><li>.value :被关联的对象</li><li>.key   :关联键</li><li>.plicy :关联行为，是个枚举</li></ul><pre><code>typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {    OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object.                                            *   The association is not made atomically. */    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied.                                            *   The association is not made atomically. */    OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.                                            *   The association is made atomically. */    OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.                                            *   The association is made atomically. */};</code></pre><h3 id="移除关联"><a href="#移除关联" class="headerlink" title="移除关联"></a>移除关联</h3><p><code>objc_removeAssociatedObjects</code></p><p><strong>通过代码来说明下：</strong></p><p>例如给UIButton的Category，添加属性(判断按钮是否被点击了)，正常Category只能扩展方法不能添加属性，但是关联对象打破了这个限制。</p><p>.m代码如下：</p><pre><code>#import &quot;UIButton+Tap.h&quot;#import &lt;objc/runtime.h&gt;static const void *associatedKey = &quot;associatedKey&quot;;@implementation UIButton (Tap)- (void)setTapButton:(Tap_button)tapButton{    objc_setAssociatedObject(self, associatedKey, tapButton, OBJC_ASSOCIATION_COPY_NONATOMIC);    [self removeTarget:self action:@selector(buttonTap:) forControlEvents:UIControlEventTouchUpInside];    if (tapButton) {        [self addTarget:self action:@selector(buttonTap:) forControlEvents:UIControlEventTouchUpInside];    }}- (Tap_button)tapButton{    return objc_getAssociatedObject(self, associatedKey);}- (void)buttonTap:(UIButton*)sender{    if (self.tapButton) {        self.tapButton();    }}</code></pre><p>调用扩展属性</p><pre><code>UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];button.tapButton = ^{    NSLog(@&quot;button tap&quot;);};</code></pre><h2 id="三、自动归档"><a href="#三、自动归档" class="headerlink" title="三、自动归档"></a>三、自动归档</h2><p>归档和解档是iOS中的序列化和反序列化操作，需要遵循NSCoding协议。<br>例如对上面的Person类进行归档和解档。初级操作如下：</p><pre><code>pragma mark --- 归档- (void)encodeWithCoder:(NSCoder *)aCoder{    //设置归档属性    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];    [aCoder encodeObject:self.idcard forKey:@&quot;idCord&quot;];    [aCoder encodeInteger:self.age forKey:@&quot;age&quot;];    [aCoder encodeFloat:self.height forKey:@&quot;height&quot;];}pragma mark --- 解档- (instancetype)initWithCoder:(NSCoder *)aDecoder{    self = [super init];    if (self) {        self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];        self.idcard = [aDecoder decodeObjectForKey:@&quot;idCord&quot;];        self.age = [[aDecoder decodeObjectForKey:@&quot;age&quot;] integerValue];        self.height = [[aDecoder decodeObjectForKey:@&quot;height&quot;] floatValue];    }    return self;}</code></pre><p>BUT，BUT，BUT这种写法太没有技术含量了，一旦模型属性数量增加，工作量就成倍增加，有了Runtime就可以轻松搞定了。</p><pre><code>pragma mark --- 归档- (void)encodeWithCoder:(NSCoder *)aCoder{    unsigned int count = 0;//属性个数    Ivar *ivars = class_copyIvarList([Person class], &amp;count);    for (int i=0; i&lt;count; i++) {        //获取属性名字        Ivar ivar = ivars[i];        const char *name = ivar_getName(ivar);//c字符串        NSString *key = [NSString stringWithUTF8String:name];//转为OC字符串        //kvc,归档        [aCoder encodeObject:[self valueForKey:key] forKey:key];    }    free(ivars);//c语言函数，ARC不能处理，需要手动释放}pragma mark --- 解档- (instancetype)initWithCoder:(NSCoder *)aDecoder{    self = [super init];    if (self) {        //解档        unsigned int count = 0;        Ivar *ivars = class_copyIvarList([Person class], &amp;count);        for (int i=0; i&lt;count; i++) {            //取出属性            Ivar ivar = ivars[i];            const char *name = ivar_getName(ivar);            NSString *key = [NSString stringWithUTF8String:name];            id value = [aDecoder decodeObjectForKey:key];            //kvc赋值            [self setValue:value forKey:key];        }        free(ivars);    }    return self;}</code></pre><p><strong>在VC中调用方法如下</strong></p><pre><code>//---自动归档Person *person = [[Person alloc] init];person.name = @&quot;Deve&quot;;person.idcard = @&quot;123456&quot;;person.age = 18;person.height = 170.0;NSString *filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;person.data&quot;];//名字取什么都行[NSKeyedArchiver archiveRootObject:person toFile:filePath];//归档//---解档//获取归档地址NSString *filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;person.data&quot;];Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath];NSLog(@&quot;person&apos;s name is %@,and age is = %ld&quot;,person.name,person.age);</code></pre><h2 id="四、模型与字典转换"><a href="#四、模型与字典转换" class="headerlink" title="四、模型与字典转换"></a>四、模型与字典转换</h2><p>这其实是最常见的场景，我们从后台拿来数据，需要对数据进行处理，往往会建立模型，也就是Model。那么用字典生成模型是怎么操作的呢？一般方法如下：</p><pre><code>- (instancetype)initWithDictionary:(NSDictionary*)dict{     if(self = [super init]){         self.name = dict[@&quot;name&quot;];         self.idCard = dict[@&quot;idCard&quot;];         ...     }     return self; }</code></pre><p><code>看上去合情合理，但是属性一多，就会很麻烦，要写很多重复类似的赋值语句。</code></p><p><strong>Runtime来解决！</strong></p><p><code>简单说下原理：</code></p><ul><li>字典转模型：利用objc_msgSend方法主动调用setter方法为Model赋值</li><li>模型转字典：利用objc_msgSend方法主动调用getter方法获取属性值生成字典</li><li>kvc也可以替换setter或getter方法</li></ul><p><strong>通过代码来说明下：</strong></p><ol><li><p>首先，建立NSObject的Category，如下：</p><pre><code>@interface NSObject (KeyValue)</code></pre></li><li><p>然后，建立两个方法，分别是字典转模型和模型转字典，如下：</p><pre><code>.h定义方法//字典转模型+(id)objectInitWithDictionary:(NSDictionary*)dic;//模型转字典- (NSDictionary*)dictionaryWithObject;.m方法实现//字典转模型+(id)objectInitWithDictionary:(NSDictionary*)dic{    id objc = [[self alloc] init];    for (NSString *key in dic.allKeys) {        id value = dic[key];//取值        //1、判断属性是不是Model，如果是Model递归改方法，如果不是向下        objc_property_t property = class_getProperty(self, key.UTF8String);//获取模型属性        unsigned int count = 0;//属性数量        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;count);        objc_property_attribute_t att = attributeList[0];//获取属性        NSString *attString = [NSString stringWithUTF8String:att.value];//转OC字符串        if ([attString isEqualToString:@&quot;@\&quot;Person\&quot;&quot;]) {             value = [self objectInitWithDictionary:value];//递归        }        //2、用objc_msgSend调用setter方法，进行赋值        NSString *methodName = [NSString stringWithFormat:@&quot;set%@%@:&quot;,[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]];//例如setName：        SEL setter= sel_registerName(methodName.UTF8String);        if ([objc respondsToSelector:setter]) {            ((void (*) (id,SEL,id)) objc_msgSend) (objc,setter,value);//runtime，发消息方法        }        free(attributeList);    }    return objc;}//模型转字典- (NSDictionary*)dictionaryWithObject{    unsigned int count = 0;    NSMutableDictionary *dic = [NSMutableDictionary dictionary];    objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);    for (int i=0; i&lt;count; i++) {        objc_property_t property = propertyList[i];        //getter方法        const char *propertyName = property_getName(property);        SEL getter = sel_registerName(propertyName);        if ([self respondsToSelector:getter]) {            id value = ((id (*) (id,SEL)) objc_msgSend)(self,getter);//获取值            //判断value是不是Model，如果是，继续递归转化为字典            if ([value isKindOfClass:[self class]] &amp;&amp; value) {                value = [value dictionaryWithObject];            }            //不是Model，继续转化            if (value) {                NSString *key = [NSString stringWithUTF8String:propertyName];                [dic setObject:value forKey:key];            }        }    }    free(propertyList);    return dic;}</code></pre></li><li><p>最后，在VC里面调用</p><pre><code>pragma mark --- 六、字典和模型互转- (void)keyValueExchange{    NSDictionary *dic = @{@&quot;name&quot;:@&quot;李磊&quot;,                          @&quot;idcard&quot;:@&quot;888888&quot;,                          @&quot;age&quot;:@5,                          @&quot;height&quot;:@170.0,                          @&quot;student&quot;:@{                                  @&quot;name&quot;:@&quot;Halen&quot;                                  }                          };    //字典转模型    Person *person = [Person objectInitWithDictionary:dic];    NSLog(@&quot;\n person&apos;s name is %@,\n person&apos;age is %ld,\n person&apos;height is %f&quot;,person.name,[person.age integerValue],[person.height floatValue]);    //模型转字典    NSDictionary *dict = [person dictionaryWithObject];    NSLog(@&quot;转换后的字典是\n%@&quot;,dict);}</code></pre></li></ol><h2 id="五、动态解析"><a href="#五、动态解析" class="headerlink" title="五、动态解析"></a>五、动态解析</h2><p>现在暂停，回到文章开头<code>预热知识点</code>，第二部分我们讲到<code>方法调用顺序</code>，在调启不存在方法时，系统会Crash，为了避免崩溃，我们可以利用<code>runtime动态解析</code>。</p><p><strong>通过代码来说明下：</strong></p><p>首先我们建立两个对象School和Teacher，如下</p><ul><li><p>school</p><pre><code>#import &lt;Foundation/Foundation.h&gt;@interface School : NSObject-(void)RecruitmentTeacher;//招聘老师@end</code></pre></li></ul><ul><li><p>teacher</p><pre><code>#import &lt;Foundation/Foundation.h&gt;@interface Teacher : NSObject- (void)haveClass;//上课@end</code></pre></li><li><p>VC里调用方法如下：</p><pre><code>School *school = [[School alloc] init];//调用((void (*) (id, SEL)) objc_msgSend) (school,sel_registerName(&quot;haveClass&quot;));</code></pre></li></ul><p>可以看到，<code>School</code>对象，调用了<code>haveClass</code>方法，但是这个方法是<code>Teacher</code>对象的。这个时候如果不做特殊处理程序就会崩溃。此时就该<code>动态解析</code>出场的了。</p><p><strong>有以下几种情况：</strong></p><ol><li>用class_addMethod方法动态添加一个方法，避免崩溃</li><li>没有动态添加方法，进行重定向forwardingTargetForSelector</li><li>重定向失败，配合签名方法methodSignatureForSelector，进行消息转发，在转发方法forwardInvocation里进行处理。</li></ol><p><strong>附上具体的.m文件代码</strong></p><pre><code>#import &quot;School.h&quot;#import &quot;Teacher.h&quot;#import &lt;objc/runtime.h&gt;@implementation School-(void)RecruitmentTeacher{    NSLog(@&quot;recruitment a teacher&quot;);}#pragma mark --- 1/* 如果当前对象调用了一个不存在的方法 Runtime会调用resolveInstanceMethod:来进行动态方法解析 我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作 返回NO，则进入下一步forwardingTargetForSelector: */+(BOOL)resolveInstanceMethod:(SEL)sel{#if 0    return NO;#else    class_addMethod(self, sel, class_getMethodImplementation(self, sel_registerName(&quot;RecruitmentTeacher&quot;)), &quot;v@:&quot;);    return [super resolveInstanceMethod:sel];#endif}#pragma mark ---2/* 在消息转发机制执行前，Runtime 系统会再给我们一次 “重定向” 的机会 通过重载forwardingTargetForSelector:方法来替换消息的接受者为其他对象 返回nil则进步下一步forwardInvocation: */-(id)forwardingTargetForSelector:(SEL)aSelector{#if 0    return nil;#else    //    return nil;    return [[Teacher alloc] init];//找到可以实现方法的对象，进行替换#endif}#pragma mark ---3/* 进行方法签名， 返回nil，表示不做签名处理， 若返回方法签名，进入下一步，消息转发 */-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{    //    return nil;    return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];}#pragma mark ---4/* 消息转发 可以做很多操作，修改实现方法，修改相应对象 */-(void)forwardInvocation:(NSInvocation *)anInvocation{    return [anInvocation invokeWithTarget:[[Teacher alloc] init]];//修改相应对象}@end</code></pre><p>Demo下载地址<a href="https://gitee.com/sslong/RuntimeLearn.git" target="_blank" rel="external">Demo下载</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;预热几个知识点&quot;&gt;&lt;a href=&quot;#预热几个知识点&quot; class=&quot;headerlink&quot; title=&quot;预热几个知识点&quot;&gt;&lt;/a&gt;预热几个知识点&lt;/h3&gt;&lt;h2 id=&quot;一、所有都是对象，方法都是消息&quot;&gt;&lt;a href=&quot;#一、所有都是对象，方法都是消息&quot; c
      
    
    </summary>
    
    
      <category term="教程" scheme="http://SunShiLong.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>xUnique解决Xcode合作开发冲突</title>
    <link href="http://SunShiLong.github.io/2018/01/31/xUnique%E5%90%88%E4%BD%9C%E5%BC%80%E5%8F%91/"/>
    <id>http://SunShiLong.github.io/2018/01/31/xUnique合作开发/</id>
    <published>2018-01-31T06:11:55.000Z</published>
    <updated>2018-01-31T06:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS合作开发过程中，经常会遇到各种问题，其中在提交代码过程中，总是会发生冲突，提交失败。xUnique可以一劳永逸的解决此类问题，提高开发效率。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li>下载地址<a href="https://github.com/truebit/xUnique.git" target="_blank" rel="external">https://github.com/truebit/xUnique.git</a></li><li><p>开始安装，如果安装失败，先卸载老版本，老版本的文件夹路径是</p><pre><code>/usr/local/bin/xunique</code></pre><p>找到后，进入xUnique源码所在文件夹，例如：</p><pre><code>~xUnique-master</code></pre><p>安装最新版（现在应该是4.1.4），在终端执行</p><pre><code>sudo python setup.py install</code></pre></li><li><p>将xUnique和git绑定，进入项目所在文件夹（一般是.xcodeproj所在），在终端执行：</p><pre><code>{ echo &apos;#!/bin/sh&apos;; echo &apos;xunique XXX&apos;; } &gt; .git/hooks/pre-commit</code></pre><p>其中，将XXX换成项目路径，例如</p><pre><code>/Users/ushitekimini/Desktop/chongtu/testPro/testPro.xcodeproj</code></pre><p>运行终端没有问题，就可以了</p></li><li><p>设置可执行权限，在终端执行：</p><pre><code>chmod 755 .git/hooks/pre-commit</code></pre><p>至此，xUnique安装完毕！</p></li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="commit两次"><a href="#commit两次" class="headerlink" title="commit两次"></a>commit两次</h2><p>为了避免提交过程中出现问题，一般commit两次 。第一次commit后看到下图，再commit一次。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oxftt42c0.bkt.clouddn.com/WechatIMG1082.jpeg" alt="第一次commit''" title="">                </div>                <div class="image-caption">第一次commit''</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在iOS合作开发过程中，经常会遇到各种问题，其中在提交代码过程中，总是会发生冲突，提交失败。xUnique可以一劳永逸的解决此类问题，提高开发效率。&lt;/p&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="教程" scheme="http://SunShiLong.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客 新手安装及使用教程</title>
    <link href="http://SunShiLong.github.io/2017/10/07/Hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>http://SunShiLong.github.io/2017/10/07/Hexo博客/</id>
    <published>2017-10-07T06:46:55.000Z</published>
    <updated>2017-10-08T03:48:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇基于Github搭建Hexo博客的基础教程，内容有：资源下载、安装步骤、发布更新文章、更换主题</p><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><ul><li>node.js ，<a href="https://nodejs.org/en/" target="_blank" rel="external">官网下载地址</a>,下载完成，双击打开，选择下一步安装即可。注：尽量下载最新版本，避免报错。</li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul><li>Xcode自带Git</li></ul><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="更换npm源"><a href="#更换npm源" class="headerlink" title="更换npm源"></a>更换npm源</h3><p>Node Package Manager 是node.js的模块依赖管理工具，由于国内有墙，使用时多有不便，国内有很多优秀的npm镜像。例如：</p><h4 id="淘宝npm"><a href="#淘宝npm" class="headerlink" title="淘宝npm"></a>淘宝npm</h4><ul><li><p>搜索地址：<a href="http://npm.taobao.org/" target="_blank" rel="external">http://npm.taobao.org/</a></p></li><li><p>registry地址：<a href="http://registry.npm.taobao.org/" target="_blank" rel="external">http://registry.npm.taobao.org/</a></p></li></ul><h4 id="cnpmjs"><a href="#cnpmjs" class="headerlink" title="cnpmjs"></a>cnpmjs</h4><ul><li><p>搜索地址：<a href="http://cnpmjs.org/" target="_blank" rel="external">http://cnpmjs.org/</a></p></li><li><p>registry地址：<a href="http://r.cnpmjs.org/" target="_blank" rel="external">http://r.cnpmjs.org/</a></p></li></ul><h4 id="配置npm"><a href="#配置npm" class="headerlink" title="配置npm"></a>配置npm</h4><p>1 . 临时使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* npm --registry https://registry.npm.taobao.org install express</div></pre></td></tr></table></figure><p>2 . 持久使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* npm config set registry https://registry.npm.taobao.org</div><div class="line">// 配置后可通过下面方式来验证是否成功</div><div class="line"></div><div class="line">* npm config get registry</div><div class="line">// 或npm info express</div></pre></td></tr></table></figure><p>3 . 使用cnpm</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* npm install -g cnpm --registry=https://registry.npm.taobao.org</div><div class="line">// 使用cnpm install expresstall express</div></pre></td></tr></table></figure><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>1 . 终端执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sudo npm install -g hexo</div></pre></td></tr></table></figure><p>输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令  -g:全局安装)</p><p>2 . 创建博客文件夹</p><p>这里可以选择一个固定的位置建立一个文件夹，例如我在‘文档’下建立一个‘MyselfBlog’的文件，以后所有操作都在这个文件下进行。</p><p>cd 到选择的目录，执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo init MyselfBlog</div></pre></td></tr></table></figure><p>cd 到MyselfBlog，安装npm，执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm install</div></pre></td></tr></table></figure><p>开启hexo 服务器，执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo s</div></pre></td></tr></table></figure><p>浏览器中打开<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></p><p>没有问题就会显示如下页面：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oxftt42c0.bkt.clouddn.com/hexoHome.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果，页面打开显示为空，4000端口被占用，终端执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo server -p 5000</div></pre></td></tr></table></figure><p>如果是其他类型的错误，到<a href="https://hexo.io/docs/server.html" target="_blank" rel="external">官网</a>排查。</p><h3 id="关联Git"><a href="#关联Git" class="headerlink" title="关联Git"></a>关联Git</h3><ul><li>登录github，新建仓库，注意命名规则‘用户名.github.io’,例如我的仓库名字就是‘SunShiLong.github.io’。仓库建立成功如下图：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oxftt42c0.bkt.clouddn.com/gitBranch.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>cd 回到‘MyselfBlog’目录，打开_config.yml文件，找到下面这段代码:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">deploy:</div><div class="line">    type: git</div><div class="line">    repository: https://github.com/XXX/XXX.github.io.git</div><div class="line">    branch: master</div></pre></td></tr></table></figure><p>注意：冒号后面有一个空格，把“XXX”换成自己仓库的名字。</p><ul><li>生成静态页面，执行：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo generate        或者：hexo g</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 此时若出现如下报错：</div><div class="line">ERROR Local hexo not found in ~/blog</div><div class="line">ERROR Try runing: &apos;npm install hexo --save&apos;</div><div class="line"></div><div class="line">// 则执行命令：</div><div class="line">$ npm install hexo --save</div><div class="line">// 若无报错，自行忽略此步骤。</div></pre></td></tr></table></figure><ul><li>配置页面，执行：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo deploy            或者：hexo d</div></pre></td></tr></table></figure><p>注意：若执行命令hexo deploy报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure><ul><li>输入git账号和密码</li></ul><h3 id="打开网页地址"><a href="#打开网页地址" class="headerlink" title="打开网页地址"></a>打开网页地址</h3><p>浏览器打开网址<a href="http://SunShiLong.github.io">http://SunShiLong.github.io</a> </p><p>本地打开<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 页面一致</p><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><ul><li>cd 到‘MyselfBlog’目录，新建文章，执行</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo new &quot;NewBlog&quot;</div></pre></td></tr></table></figure><ul><li>可以看到新建一个名为“NewBlog.md”的文件目录在MyselfBlog/source/_posts下，这里推荐使用markdown编辑博客，Mac端好用的编辑器有Mou和MacDown，但是Mou目前最高支持MacOS10.11，我的电脑系统是10.12，所有只好用MacDown。当然喜欢Vim的不受影响啦。</li></ul><p>MacDown编辑器效果如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oxftt42c0.bkt.clouddn.com/macdown.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还不错吧，可以边码字边预览。</p><ul><li>文章编辑完成，接下来就可以发布了，还是执行下面两句：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo generate          //生成静态页面</div><div class="line"></div><div class="line">$ hexo deploy            //部署到Github</div></pre></td></tr></table></figure><p><strong>NOW, Hexo博客搭建教程就告一段落了</strong></p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>所有基于github建立的hexo博客，默认主题都是landscape，可以自定义的，到<a href="https://hexo.io/themes/" target="_blank" rel="external">主题官网</a>选好自己喜欢的主题，例如主题Ada</p><p>cd 到‘MyselfBlog‘目录，执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ git clone https://github.com/shuiRong/hexo-theme-Ada.git themes/Ada</div><div class="line">// 将MyselfBlog目录下_config.yml里theme的名称landscape修改为Ada</div><div class="line"></div><div class="line">$ hexo clean         //清除缓存文件 (db.json) 和静态文件 (public)</div><div class="line">$ hexo g             //生成缓存和静态文件</div><div class="line">$ hexo d             //重新部署到服务器</div></pre></td></tr></table></figure><p>每个主题都有详细的介绍，包括使用方法和内容修改，可以替换，名字、标题、图片、网址等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一篇基于Github搭建Hexo博客的基础教程，内容有：资源下载、安装步骤、发布更新文章、更换主题&lt;/p&gt;
&lt;h2 id=&quot;资源下载&quot;&gt;&lt;a href=&quot;#资源下载&quot; class=&quot;headerlink&quot; title=&quot;资源下载&quot;&gt;&lt;/a&gt;资源下载&lt;/h2&gt;&lt;h3 id
      
    
    </summary>
    
    
      <category term="教程" scheme="http://SunShiLong.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
