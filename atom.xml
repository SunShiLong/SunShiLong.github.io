<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学不车</title>
  <icon>https://www.gravatar.com/avatar/b6b5b12bec5eefda89480d0aa50e9688</icon>
  <subtitle>一天不学问题多，两天不学走下坡。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://SunShiLong.github.io/"/>
  <updated>2018-02-12T08:56:39.000Z</updated>
  <id>http://SunShiLong.github.io/</id>
  
  <author>
    <name>孙世龙</name>
    <email>1577908011@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Runtime机制</title>
    <link href="http://SunShiLong.github.io/2018/02/12/Runtime%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%AD%99%E4%B8%96%E9%BE%99%EF%BC%89/"/>
    <id>http://SunShiLong.github.io/2018/02/12/Runtime详解（孙世龙）/</id>
    <published>2018-02-11T16:00:00.000Z</published>
    <updated>2018-02-12T08:56:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预热几个知识点"><a href="#预热几个知识点" class="headerlink" title="预热几个知识点"></a>预热几个知识点</h3><h2 id="一、所有都是对象，方法都是消息"><a href="#一、所有都是对象，方法都是消息" class="headerlink" title="一、所有都是对象，方法都是消息"></a>一、所有都是对象，方法都是消息</h2><blockquote><p>1、OC中所有id类型都被设计成对象，类本身也是一个对象。OC代码在运行时会动态转化为C代码。</p><p>2、所有方法调用都是发消息，例如<code>[self init];</code>被转化为<code>objc_msgSend(self,@selector(init))</code></p></blockquote><p>在OC中id指针，可以代表所有对象，其实id是结构体，我们看看id的具体结构：</p><pre><code>struct objc_class {    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;#if !__OBJC2__    Class _Nullable super_class                              OBJC2_UNAVAILABLE;    const char * _Nonnull name                               OBJC2_UNAVAILABLE;    long version                                             OBJC2_UNAVAILABLE;    long info                                                OBJC2_UNAVAILABLE;    long instance_size                                       OBJC2_UNAVAILABLE;    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;#endif} OBJC2_UNAVAILABLE;</code></pre><p><strong>这是属性都是什么意思呢？下面一一介绍</strong></p><ul><li>.Class 的isa指针，指向元类</li><li>.super_class ：指向超类</li><li>.name是类名</li><li>.version是类版本信息</li><li>.info是这个类的详情信息</li><li>.instance_size是这个类实例对象的大小</li><li>.ivars是类成员变量</li><li>.methodLists类的方法列表</li><li>.cache是，存储被调用过的方法，方便下次使用</li><li>.protocols是类的协议列表</li></ul><h2 id="二、方法调用顺序"><a href="#二、方法调用顺序" class="headerlink" title="二、方法调用顺序"></a>二、方法调用顺序</h2><ol><li>调用一个<code>方法A</code>，首先runtime把方法转为消息发送，可以简单理解为<code>objc_msgSend</code>。</li><li>在<code>cache</code>里查找，找到执行，否则</li><li>在本类的<code>methodLists</code>中查找，找到执行，否则</li><li>在父类中重复2、3步骤</li><li>直到<code>根类NSObject</code>都没找到，转向<code>方法拦截</code></li><li>动态解析<code>方法A</code>，判断是不是系统忽略方法，例如retain、release等</li><li>判断<code>调用者target</code>是不是nil，<code>OC语法允许nil对象调用不存在方法而不Crash</code>。</li><li>进入第二阶段，<code>消息转发</code></li><li>进入 <code>resolveInstanceMethod:</code> 方法。如果返回YES，调用<code>class_addMethod</code>，执行方法完成。如果返回NO，向下</li><li>进入重定向 <code>forwardingTargetForSelector:</code> ，指定一个可以实现<code>方法A</code>对象，完成这次调用。如果返回nil，向下</li><li>进入方法签名操作 <code>methodSignatureForSelector:</code> ，如果签名成功，有返回值，这时会调用消息转发方法<code>forwardInvocation:</code>。</li><li>在<code>forwardInvocation:</code>中可以修改实现方法、修改响应对象。</li></ol><h2 id="三、获取参数"><a href="#三、获取参数" class="headerlink" title="三、获取参数"></a>三、获取参数</h2><p><strong>runtime可以获取类的各种参数，方法如下：</strong></p><ul><li>class_copyPropertyList：获取属性列表</li><li>class_copyMethodList：获取方法列表</li><li>class_copyIvarList：获取成员变量</li><li>class_copyProtocolList：获取协议列表</li></ul><h1 id="Runtime用途"><a href="#Runtime用途" class="headerlink" title="Runtime用途"></a>Runtime用途</h1><h2 id="一、直接通过C发送消息，来调用方法"><a href="#一、直接通过C发送消息，来调用方法" class="headerlink" title="一、直接通过C发送消息，来调用方法"></a>一、直接通过C发送消息，来调用方法</h2><ul><li>objc_msgSend:调用普通方法</li><li>objc_msgSend_stret：消息返回值是数据结构</li><li>objc_msgSend_fpret：消息返回值是浮点数</li><li>objc_msgSendSuper：调用父类方法</li><li>objc_msgSendSuper_stret：父类消息返回值是数据结构</li></ul><p><strong>通过代码来说明下：</strong></p><p>新建一个Person类</p><pre><code>@interface Person : NSObject@property (nonatomic,strong) NSString  *name;@property (nonatomic,strong) NSString  *idcard;@property (nonatomic)        NSInteger age;</code></pre><p>person有下面方法</p><pre><code>- (void)hello:(NSString*)name andAge:(NSInteger)age;- (NSString*)goodMornig:(NSString*)name;- (float)getHeight;</code></pre><p>正常情况下，OC调用方法如下</p><pre><code>Person *person = [[Person alloc] init];[person hello:@&quot;Dave&quot; andAge:12];</code></pre><p>在runtime机制下，可以直接用c方法调用，如下</p><pre><code>1、((void (*) (id, SEL)) objc_msgSend) (person, sel_registerName(&quot;hello:andAge:&quot;));2、NSString *str = ((NSString* (*) (id, SEL)) objc_msgSend) (person, sel_registerName(&quot;goodMornig:&quot;));3、float f = ((float (*) (id, SEL)) objc_msgSend_fpret) (objct, sel_registerName(&quot;getHeight&quot;));</code></pre><h2 id="二、关联对象"><a href="#二、关联对象" class="headerlink" title="二、关联对象"></a>二、关联对象</h2><p>允许开发者对已经存在的对象在 Category 中添加自定义的属性：<br>设置关联对象核心方法是：</p><p><code>OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</code></p><h3 id="参数解析："><a href="#参数解析：" class="headerlink" title="参数解析："></a>参数解析：</h3><ul><li>.object:源对象</li><li>.value :被关联的对象</li><li>.key   :关联键</li><li>.plicy :关联行为，是个枚举</li></ul><pre><code>typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {    OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object.                                            *   The association is not made atomically. */    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied.                                            *   The association is not made atomically. */    OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.                                            *   The association is made atomically. */    OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.                                            *   The association is made atomically. */};</code></pre><h3 id="移除关联"><a href="#移除关联" class="headerlink" title="移除关联"></a>移除关联</h3><p><code>objc_removeAssociatedObjects</code></p><p><strong>通过代码来说明下：</strong></p><p>例如给UIButton的Category，添加属性(判断按钮是否被点击了)，正常Category只能扩展方法不能添加属性，但是关联对象打破了这个限制。</p><p>.m代码如下：</p><pre><code>#import &quot;UIButton+Tap.h&quot;#import &lt;objc/runtime.h&gt;static const void *associatedKey = &quot;associatedKey&quot;;@implementation UIButton (Tap)- (void)setTapButton:(Tap_button)tapButton{    objc_setAssociatedObject(self, associatedKey, tapButton, OBJC_ASSOCIATION_COPY_NONATOMIC);    [self removeTarget:self action:@selector(buttonTap:) forControlEvents:UIControlEventTouchUpInside];    if (tapButton) {        [self addTarget:self action:@selector(buttonTap:) forControlEvents:UIControlEventTouchUpInside];    }}- (Tap_button)tapButton{    return objc_getAssociatedObject(self, associatedKey);}- (void)buttonTap:(UIButton*)sender{    if (self.tapButton) {        self.tapButton();    }}</code></pre><p>调用扩展属性</p><pre><code>UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];button.tapButton = ^{    NSLog(@&quot;button tap&quot;);};</code></pre><h2 id="三、自动归档"><a href="#三、自动归档" class="headerlink" title="三、自动归档"></a>三、自动归档</h2><p>归档和解档是iOS中的序列化和反序列化操作，需要遵循NSCoding协议。<br>例如对上面的Person类进行归档和解档。初级操作如下：</p><pre><code>pragma mark --- 归档- (void)encodeWithCoder:(NSCoder *)aCoder{    //设置归档属性    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];    [aCoder encodeObject:self.idcard forKey:@&quot;idCord&quot;];    [aCoder encodeInteger:self.age forKey:@&quot;age&quot;];    [aCoder encodeFloat:self.height forKey:@&quot;height&quot;];}pragma mark --- 解档- (instancetype)initWithCoder:(NSCoder *)aDecoder{    self = [super init];    if (self) {        self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];        self.idcard = [aDecoder decodeObjectForKey:@&quot;idCord&quot;];        self.age = [[aDecoder decodeObjectForKey:@&quot;age&quot;] integerValue];        self.height = [[aDecoder decodeObjectForKey:@&quot;height&quot;] floatValue];    }    return self;}</code></pre><p>BUT，BUT，BUT这种写法太没有技术含量了，一旦模型属性数量增加，工作量就成倍增加，有了Runtime就可以轻松搞定了。</p><pre><code>pragma mark --- 归档- (void)encodeWithCoder:(NSCoder *)aCoder{    unsigned int count = 0;//属性个数    Ivar *ivars = class_copyIvarList([Person class], &amp;count);    for (int i=0; i&lt;count; i++) {        //获取属性名字        Ivar ivar = ivars[i];        const char *name = ivar_getName(ivar);//c字符串        NSString *key = [NSString stringWithUTF8String:name];//转为OC字符串        //kvc,归档        [aCoder encodeObject:[self valueForKey:key] forKey:key];    }    free(ivars);//c语言函数，ARC不能处理，需要手动释放}pragma mark --- 解档- (instancetype)initWithCoder:(NSCoder *)aDecoder{    self = [super init];    if (self) {        //解档        unsigned int count = 0;        Ivar *ivars = class_copyIvarList([Person class], &amp;count);        for (int i=0; i&lt;count; i++) {            //取出属性            Ivar ivar = ivars[i];            const char *name = ivar_getName(ivar);            NSString *key = [NSString stringWithUTF8String:name];            id value = [aDecoder decodeObjectForKey:key];            //kvc赋值            [self setValue:value forKey:key];        }        free(ivars);    }    return self;}</code></pre><p><strong>在VC中调用方法如下</strong></p><pre><code>//---自动归档Person *person = [[Person alloc] init];person.name = @&quot;Deve&quot;;person.idcard = @&quot;123456&quot;;person.age = 18;person.height = 170.0;NSString *filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;person.data&quot;];//名字取什么都行[NSKeyedArchiver archiveRootObject:person toFile:filePath];//归档//---解档//获取归档地址NSString *filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;person.data&quot;];Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath];NSLog(@&quot;person&apos;s name is %@,and age is = %ld&quot;,person.name,person.age);</code></pre><h2 id="四、模型与字典转换"><a href="#四、模型与字典转换" class="headerlink" title="四、模型与字典转换"></a>四、模型与字典转换</h2><p>这其实是最常见的场景，我们从后台拿来数据，需要对数据进行处理，往往会建立模型，也就是Model。那么用字典生成模型是怎么操作的呢？一般方法如下：</p><pre><code>- (instancetype)initWithDictionary:(NSDictionary*)dict{     if(self = [super init]){         self.name = dict[@&quot;name&quot;];         self.idCard = dict[@&quot;idCard&quot;];         ...     }     return self; }</code></pre><p><code>看上去合情合理，但是属性一多，就会很麻烦，要写很多重复类似的赋值语句。</code></p><p><strong>Runtime来解决！</strong></p><p><code>简单说下原理：</code></p><ul><li>字典转模型：利用objc_msgSend方法主动调用setter方法为Model赋值</li><li>模型转字典：利用objc_msgSend方法主动调用getter方法获取属性值生成字典</li><li>kvc也可以替换setter或getter方法</li></ul><p><strong>通过代码来说明下：</strong></p><ol><li><p>首先，建立NSObject的Category，如下：</p><pre><code>@interface NSObject (KeyValue)</code></pre></li><li><p>然后，建立两个方法，分别是字典转模型和模型转字典，如下：</p><pre><code>.h定义方法//字典转模型+(id)objectInitWithDictionary:(NSDictionary*)dic;//模型转字典- (NSDictionary*)dictionaryWithObject;.m方法实现//字典转模型+(id)objectInitWithDictionary:(NSDictionary*)dic{    id objc = [[self alloc] init];    for (NSString *key in dic.allKeys) {        id value = dic[key];//取值        //1、判断属性是不是Model，如果是Model递归改方法，如果不是向下        objc_property_t property = class_getProperty(self, key.UTF8String);//获取模型属性        unsigned int count = 0;//属性数量        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;count);        objc_property_attribute_t att = attributeList[0];//获取属性        NSString *attString = [NSString stringWithUTF8String:att.value];//转OC字符串        if ([attString isEqualToString:@&quot;@\&quot;Person\&quot;&quot;]) {             value = [self objectInitWithDictionary:value];//递归        }        //2、用objc_msgSend调用setter方法，进行赋值        NSString *methodName = [NSString stringWithFormat:@&quot;set%@%@:&quot;,[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]];//例如setName：        SEL setter= sel_registerName(methodName.UTF8String);        if ([objc respondsToSelector:setter]) {            ((void (*) (id,SEL,id)) objc_msgSend) (objc,setter,value);//runtime，发消息方法        }        free(attributeList);    }    return objc;}//模型转字典- (NSDictionary*)dictionaryWithObject{    unsigned int count = 0;    NSMutableDictionary *dic = [NSMutableDictionary dictionary];    objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);    for (int i=0; i&lt;count; i++) {        objc_property_t property = propertyList[i];        //getter方法        const char *propertyName = property_getName(property);        SEL getter = sel_registerName(propertyName);        if ([self respondsToSelector:getter]) {            id value = ((id (*) (id,SEL)) objc_msgSend)(self,getter);//获取值            //判断value是不是Model，如果是，继续递归转化为字典            if ([value isKindOfClass:[self class]] &amp;&amp; value) {                value = [value dictionaryWithObject];            }            //不是Model，继续转化            if (value) {                NSString *key = [NSString stringWithUTF8String:propertyName];                [dic setObject:value forKey:key];            }        }    }    free(propertyList);    return dic;}</code></pre></li><li><p>最后，在VC里面调用</p><pre><code>pragma mark --- 六、字典和模型互转- (void)keyValueExchange{    NSDictionary *dic = @{@&quot;name&quot;:@&quot;李磊&quot;,                          @&quot;idcard&quot;:@&quot;888888&quot;,                          @&quot;age&quot;:@5,                          @&quot;height&quot;:@170.0,                          @&quot;student&quot;:@{                                  @&quot;name&quot;:@&quot;Halen&quot;                                  }                          };    //字典转模型    Person *person = [Person objectInitWithDictionary:dic];    NSLog(@&quot;\n person&apos;s name is %@,\n person&apos;age is %ld,\n person&apos;height is %f&quot;,person.name,[person.age integerValue],[person.height floatValue]);    //模型转字典    NSDictionary *dict = [person dictionaryWithObject];    NSLog(@&quot;转换后的字典是\n%@&quot;,dict);}</code></pre></li></ol><h2 id="五、动态解析"><a href="#五、动态解析" class="headerlink" title="五、动态解析"></a>五、动态解析</h2><p>现在暂停，回到文章开头<code>预热知识点</code>，第二部分我们讲到<code>方法调用顺序</code>，在调启不存在方法时，系统会Crash，为了避免崩溃，我们可以利用<code>runtime动态解析</code>。</p><p><strong>通过代码来说明下：</strong></p><p>首先我们建立两个对象School和Teacher，如下</p><ul><li><p>school</p><pre><code>#import &lt;Foundation/Foundation.h&gt;@interface School : NSObject-(void)RecruitmentTeacher;//招聘老师@end</code></pre></li></ul><ul><li><p>teacher</p><pre><code>#import &lt;Foundation/Foundation.h&gt;@interface Teacher : NSObject- (void)haveClass;//上课@end</code></pre></li><li><p>VC里调用方法如下：</p><pre><code>School *school = [[School alloc] init];//调用((void (*) (id, SEL)) objc_msgSend) (school,sel_registerName(&quot;haveClass&quot;));</code></pre></li></ul><p>可以看到，<code>School</code>对象，调用了<code>haveClass</code>方法，但是这个方法是<code>Teacher</code>对象的。这个时候如果不做特殊处理程序就会崩溃。此时就该<code>动态解析</code>出场的了。</p><p><strong>有以下几种情况：</strong></p><ol><li>用class_addMethod方法动态添加一个方法，避免崩溃</li><li>没有动态添加方法，进行重定向forwardingTargetForSelector</li><li>重定向失败，配合签名方法methodSignatureForSelector，进行消息转发，在转发方法forwardInvocation里进行处理。</li></ol><p><strong>附上具体的.m文件代码</strong></p><pre><code>#import &quot;School.h&quot;#import &quot;Teacher.h&quot;#import &lt;objc/runtime.h&gt;@implementation School-(void)RecruitmentTeacher{    NSLog(@&quot;recruitment a teacher&quot;);}#pragma mark --- 1/* 如果当前对象调用了一个不存在的方法 Runtime会调用resolveInstanceMethod:来进行动态方法解析 我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作 返回NO，则进入下一步forwardingTargetForSelector: */+(BOOL)resolveInstanceMethod:(SEL)sel{#if 0    return NO;#else    class_addMethod(self, sel, class_getMethodImplementation(self, sel_registerName(&quot;RecruitmentTeacher&quot;)), &quot;v@:&quot;);    return [super resolveInstanceMethod:sel];#endif}#pragma mark ---2/* 在消息转发机制执行前，Runtime 系统会再给我们一次 “重定向” 的机会 通过重载forwardingTargetForSelector:方法来替换消息的接受者为其他对象 返回nil则进步下一步forwardInvocation: */-(id)forwardingTargetForSelector:(SEL)aSelector{#if 0    return nil;#else    //    return nil;    return [[Teacher alloc] init];//找到可以实现方法的对象，进行替换#endif}#pragma mark ---3/* 进行方法签名， 返回nil，表示不做签名处理， 若返回方法签名，进入下一步，消息转发 */-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{    //    return nil;    return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];}#pragma mark ---4/* 消息转发 可以做很多操作，修改实现方法，修改相应对象 */-(void)forwardInvocation:(NSInvocation *)anInvocation{    return [anInvocation invokeWithTarget:[[Teacher alloc] init]];//修改相应对象}@end</code></pre><p>Demo下载地址<a href="https://gitee.com/sslong/RuntimeLearn.git" target="_blank" rel="external">Demo下载</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;预热几个知识点&quot;&gt;&lt;a href=&quot;#预热几个知识点&quot; class=&quot;headerlink&quot; title=&quot;预热几个知识点&quot;&gt;&lt;/a&gt;预热几个知识点&lt;/h3&gt;&lt;h2 id=&quot;一、所有都是对象，方法都是消息&quot;&gt;&lt;a href=&quot;#一、所有都是对象，方法都是消息&quot; c
      
    
    </summary>
    
    
      <category term="教程" scheme="http://SunShiLong.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>xUnique解决Xcode合作开发冲突</title>
    <link href="http://SunShiLong.github.io/2018/01/31/xUnique%E5%90%88%E4%BD%9C%E5%BC%80%E5%8F%91/"/>
    <id>http://SunShiLong.github.io/2018/01/31/xUnique合作开发/</id>
    <published>2018-01-31T06:11:55.000Z</published>
    <updated>2018-01-31T06:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS合作开发过程中，经常会遇到各种问题，其中在提交代码过程中，总是会发生冲突，提交失败。xUnique可以一劳永逸的解决此类问题，提高开发效率。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li>下载地址<a href="https://github.com/truebit/xUnique.git" target="_blank" rel="external">https://github.com/truebit/xUnique.git</a></li><li><p>开始安装，如果安装失败，先卸载老版本，老版本的文件夹路径是</p><pre><code>/usr/local/bin/xunique</code></pre><p>找到后，进入xUnique源码所在文件夹，例如：</p><pre><code>~xUnique-master</code></pre><p>安装最新版（现在应该是4.1.4），在终端执行</p><pre><code>sudo python setup.py install</code></pre></li><li><p>将xUnique和git绑定，进入项目所在文件夹（一般是.xcodeproj所在），在终端执行：</p><pre><code>{ echo &apos;#!/bin/sh&apos;; echo &apos;xunique XXX&apos;; } &gt; .git/hooks/pre-commit</code></pre><p>其中，将XXX换成项目路径，例如</p><pre><code>/Users/ushitekimini/Desktop/chongtu/testPro/testPro.xcodeproj</code></pre><p>运行终端没有问题，就可以了</p></li><li><p>设置可执行权限，在终端执行：</p><pre><code>chmod 755 .git/hooks/pre-commit</code></pre><p>至此，xUnique安装完毕！</p></li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="commit两次"><a href="#commit两次" class="headerlink" title="commit两次"></a>commit两次</h2><p>为了避免提交过程中出现问题，一般commit两次 。第一次commit后看到下图，再commit一次。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oxftt42c0.bkt.clouddn.com/WechatIMG1082.jpeg" alt="第一次commit''" title="">                </div>                <div class="image-caption">第一次commit''</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在iOS合作开发过程中，经常会遇到各种问题，其中在提交代码过程中，总是会发生冲突，提交失败。xUnique可以一劳永逸的解决此类问题，提高开发效率。&lt;/p&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="教程" scheme="http://SunShiLong.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客 新手安装及使用教程</title>
    <link href="http://SunShiLong.github.io/2017/10/07/Hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>http://SunShiLong.github.io/2017/10/07/Hexo博客/</id>
    <published>2017-10-07T06:46:55.000Z</published>
    <updated>2017-10-08T03:48:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇基于Github搭建Hexo博客的基础教程，内容有：资源下载、安装步骤、发布更新文章、更换主题</p><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><ul><li>node.js ，<a href="https://nodejs.org/en/" target="_blank" rel="external">官网下载地址</a>,下载完成，双击打开，选择下一步安装即可。注：尽量下载最新版本，避免报错。</li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul><li>Xcode自带Git</li></ul><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="更换npm源"><a href="#更换npm源" class="headerlink" title="更换npm源"></a>更换npm源</h3><p>Node Package Manager 是node.js的模块依赖管理工具，由于国内有墙，使用时多有不便，国内有很多优秀的npm镜像。例如：</p><h4 id="淘宝npm"><a href="#淘宝npm" class="headerlink" title="淘宝npm"></a>淘宝npm</h4><ul><li><p>搜索地址：<a href="http://npm.taobao.org/" target="_blank" rel="external">http://npm.taobao.org/</a></p></li><li><p>registry地址：<a href="http://registry.npm.taobao.org/" target="_blank" rel="external">http://registry.npm.taobao.org/</a></p></li></ul><h4 id="cnpmjs"><a href="#cnpmjs" class="headerlink" title="cnpmjs"></a>cnpmjs</h4><ul><li><p>搜索地址：<a href="http://cnpmjs.org/" target="_blank" rel="external">http://cnpmjs.org/</a></p></li><li><p>registry地址：<a href="http://r.cnpmjs.org/" target="_blank" rel="external">http://r.cnpmjs.org/</a></p></li></ul><h4 id="配置npm"><a href="#配置npm" class="headerlink" title="配置npm"></a>配置npm</h4><p>1 . 临时使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* npm --registry https://registry.npm.taobao.org install express</div></pre></td></tr></table></figure><p>2 . 持久使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* npm config set registry https://registry.npm.taobao.org</div><div class="line">// 配置后可通过下面方式来验证是否成功</div><div class="line"></div><div class="line">* npm config get registry</div><div class="line">// 或npm info express</div></pre></td></tr></table></figure><p>3 . 使用cnpm</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* npm install -g cnpm --registry=https://registry.npm.taobao.org</div><div class="line">// 使用cnpm install expresstall express</div></pre></td></tr></table></figure><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>1 . 终端执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sudo npm install -g hexo</div></pre></td></tr></table></figure><p>输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令  -g:全局安装)</p><p>2 . 创建博客文件夹</p><p>这里可以选择一个固定的位置建立一个文件夹，例如我在‘文档’下建立一个‘MyselfBlog’的文件，以后所有操作都在这个文件下进行。</p><p>cd 到选择的目录，执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo init MyselfBlog</div></pre></td></tr></table></figure><p>cd 到MyselfBlog，安装npm，执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm install</div></pre></td></tr></table></figure><p>开启hexo 服务器，执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo s</div></pre></td></tr></table></figure><p>浏览器中打开<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></p><p>没有问题就会显示如下页面：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oxftt42c0.bkt.clouddn.com/hexoHome.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果，页面打开显示为空，4000端口被占用，终端执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo server -p 5000</div></pre></td></tr></table></figure><p>如果是其他类型的错误，到<a href="https://hexo.io/docs/server.html" target="_blank" rel="external">官网</a>排查。</p><h3 id="关联Git"><a href="#关联Git" class="headerlink" title="关联Git"></a>关联Git</h3><ul><li>登录github，新建仓库，注意命名规则‘用户名.github.io’,例如我的仓库名字就是‘SunShiLong.github.io’。仓库建立成功如下图：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oxftt42c0.bkt.clouddn.com/gitBranch.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>cd 回到‘MyselfBlog’目录，打开_config.yml文件，找到下面这段代码:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">deploy:</div><div class="line">    type: git</div><div class="line">    repository: https://github.com/XXX/XXX.github.io.git</div><div class="line">    branch: master</div></pre></td></tr></table></figure><p>注意：冒号后面有一个空格，把“XXX”换成自己仓库的名字。</p><ul><li>生成静态页面，执行：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo generate        或者：hexo g</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 此时若出现如下报错：</div><div class="line">ERROR Local hexo not found in ~/blog</div><div class="line">ERROR Try runing: &apos;npm install hexo --save&apos;</div><div class="line"></div><div class="line">// 则执行命令：</div><div class="line">$ npm install hexo --save</div><div class="line">// 若无报错，自行忽略此步骤。</div></pre></td></tr></table></figure><ul><li>配置页面，执行：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo deploy            或者：hexo d</div></pre></td></tr></table></figure><p>注意：若执行命令hexo deploy报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure><ul><li>输入git账号和密码</li></ul><h3 id="打开网页地址"><a href="#打开网页地址" class="headerlink" title="打开网页地址"></a>打开网页地址</h3><p>浏览器打开网址<a href="http://SunShiLong.github.io">http://SunShiLong.github.io</a> </p><p>本地打开<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 页面一致</p><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><ul><li>cd 到‘MyselfBlog’目录，新建文章，执行</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo new &quot;NewBlog&quot;</div></pre></td></tr></table></figure><ul><li>可以看到新建一个名为“NewBlog.md”的文件目录在MyselfBlog/source/_posts下，这里推荐使用markdown编辑博客，Mac端好用的编辑器有Mou和MacDown，但是Mou目前最高支持MacOS10.11，我的电脑系统是10.12，所有只好用MacDown。当然喜欢Vim的不受影响啦。</li></ul><p>MacDown编辑器效果如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oxftt42c0.bkt.clouddn.com/macdown.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>还不错吧，可以边码字边预览。</p><ul><li>文章编辑完成，接下来就可以发布了，还是执行下面两句：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo generate          //生成静态页面</div><div class="line"></div><div class="line">$ hexo deploy            //部署到Github</div></pre></td></tr></table></figure><p><strong>NOW, Hexo博客搭建教程就告一段落了</strong></p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>所有基于github建立的hexo博客，默认主题都是landscape，可以自定义的，到<a href="https://hexo.io/themes/" target="_blank" rel="external">主题官网</a>选好自己喜欢的主题，例如主题Ada</p><p>cd 到‘MyselfBlog‘目录，执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ git clone https://github.com/shuiRong/hexo-theme-Ada.git themes/Ada</div><div class="line">// 将MyselfBlog目录下_config.yml里theme的名称landscape修改为Ada</div><div class="line"></div><div class="line">$ hexo clean         //清除缓存文件 (db.json) 和静态文件 (public)</div><div class="line">$ hexo g             //生成缓存和静态文件</div><div class="line">$ hexo d             //重新部署到服务器</div></pre></td></tr></table></figure><p>每个主题都有详细的介绍，包括使用方法和内容修改，可以替换，名字、标题、图片、网址等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一篇基于Github搭建Hexo博客的基础教程，内容有：资源下载、安装步骤、发布更新文章、更换主题&lt;/p&gt;
&lt;h2 id=&quot;资源下载&quot;&gt;&lt;a href=&quot;#资源下载&quot; class=&quot;headerlink&quot; title=&quot;资源下载&quot;&gt;&lt;/a&gt;资源下载&lt;/h2&gt;&lt;h3 id
      
    
    </summary>
    
    
      <category term="教程" scheme="http://SunShiLong.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
